# awesome-algorithm-note
常用算法：穷举法、回溯法、分治递归、贪心法、动态规划

穷举：也就是枚举法，都一一列出来

回溯：按照某一顺序进行检验，当当前候选不满足条件时，回退到上一步重新选择下一候选

分治：自顶向下的设计，将一个大问题分割若干子问题，各个击破，分而治之，然后子问题解集合起来得出原解

贪心：寄希望于局部最优解得出全局最优解

动态规划：分解的子问题不是互相独立的，保存一个表记录所有已解决的子问题的答案

## 复杂度分析

![img](./img/time.png)

<img src="./img/time-graph.png" alt="img" style="zoom:80%;" />

O(1): 操作数量与输入数据大小 n 无关

O(n): 单层循环

O(n<sup>2</sup>): 嵌套循环

O(2<sup>n</sup>): 二叉树、递归、细胞分裂；指数阶增长非常迅速，在穷举法（暴力搜索、回溯等）中常见。对于数据较大的问题是不可接受的，通常需要使用动态规划或贪心算法等来解决。

O(log n): 分治、递归、每轮缩减一半

O(nlog n): 两层循环，一层n，一层log n

O(n!): 递归，全排列 n! = n * (n-1) * ... * 2 * 1

## 数据结构

- **线性数据结构**：数组、链表、栈、队列、哈希表，元素之间是一对一的顺序关系。
- **非线性数据结构**：树、堆、图、哈希表。

![structure](./img/structure.png)

### 基本数据类型

- 整数类型 `byte`、`short`、`int`、`long` 。
- 浮点数类型 `float`、`double` ，用于表示小数。
- 字符类型 `char` ，用于表示各种语言的字母、标点符号甚至表情符号等。
- 布尔类型 `bool` ，用于表示“是”与“否”判断。

### 绪论

- 原码、反码和补码是在计算机中编码数字的三种方法，它们之间可以相互转换。整数的原码的最高位是符号位，其余位是数字的值。
- 整数在计算机中是以补码的形式存储的。在补码表示下，计算机可以对正数和负数的加法一视同仁，不需要为减法操作单独设计特殊的硬件电路，并且不存在正负零歧义的问题。
- 浮点数的编码由 1 位符号位、8 位指数位和 23 位分数位构成。由于存在指数位，因此浮点数的取值范围远大于整数，代价是牺牲了精度。
- ASCII 码是最早出现的英文字符集，长度为 1 字节，共收录 127 个字符。GBK 字符集是常用的中文字符集，共收录两万多个汉字。Unicode 致力于提供一个完整的字符集标准，收录世界上各种语言的字符，从而解决由于字符编码方法不一致而导致的乱码问题。
- UTF-8 是最受欢迎的 Unicode 编码方法，通用性非常好。它是一种变长的编码方法，具有很好的扩展性，有效提升了存储空间的使用效率。UTF-16 和 UTF-32 是等长的编码方法。在编码中文时，UTF-16 占用的空间比 UTF-8 更小。Java 和 C# 等编程语言默认使用 UTF-16 编码。

## 数组与链表

```typescript
/* 初始化数组 */
let arr: number[] = new Array(5).fill(0);
let nums: number[] = [1, 3, 2, 5, 4];
/* 访问数组 */
nums[index] //复杂度O(1)
```

| 操作     | 方法                                           | 示例                              |
| :------- | :--------------------------------------------- | :-------------------------------- |
| **插入** | `push()`                                       | `arr.push(4)` 数组尾部插入        |
|          | `unshift()`                                    | `arr.unshift(0)` 数组头部插入     |
|          | `splice(index, deleteNum, addItem1, addItem2)` | `arr.splice(1, 0, 1.5)`           |
| **删除** | `pop()`                                        | `arr.pop()` 尾部                  |
|          | `shift()`                                      | `arr.shift()` 头部                |
|          | `splice()`                                     | `arr.splice(1, 2)`                |
|          | `filter()`                                     | `arr.filter(item => item == 3)`   |
|          | `slice(beginIndex, endIndex)`                  | 包前不包后                        |
| **查找** | `indexOf()`                                    | `arr.indexOf(3)`                  |
|          | `includes()`                                   | `arr.includes(3)`                 |
|          | `find()`                                       | `arr.find(item => item > 2)`      |
|          | `findIndex()`                                  | `arr.findIndex(item => item > 2)` |
